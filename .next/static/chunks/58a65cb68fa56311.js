(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,33525,(e,t,a)=>{"use strict";Object.defineProperty(a,"__esModule",{value:!0}),Object.defineProperty(a,"warnOnce",{enumerable:!0,get:function(){return i}});let i=e=>{}},75254,e=>{"use strict";var t=e.i(71645);let a=(...e)=>e.filter((e,t,a)=>!!e&&""!==e.trim()&&a.indexOf(e)===t).join(" ").trim(),i=e=>{let t=e.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,a)=>a?a.toUpperCase():t.toLowerCase());return t.charAt(0).toUpperCase()+t.slice(1)};var r={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};let s=(0,t.forwardRef)(({color:e="currentColor",size:i=24,strokeWidth:s=2,absoluteStrokeWidth:o,className:n="",children:c,iconNode:d,...l},m)=>(0,t.createElement)("svg",{ref:m,...r,width:i,height:i,stroke:e,strokeWidth:o?24*Number(s)/Number(i):s,className:a("lucide",n),...!c&&!(e=>{for(let t in e)if(t.startsWith("aria-")||"role"===t||"title"===t)return!0;return!1})(l)&&{"aria-hidden":"true"},...l},[...d.map(([e,a])=>(0,t.createElement)(e,a)),...Array.isArray(c)?c:[c]])),o=(e,r)=>{let o=(0,t.forwardRef)(({className:o,...n},c)=>(0,t.createElement)(s,{ref:c,iconNode:r,className:a(`lucide-${i(e).replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()}`,`lucide-${e}`,o),...n}));return o.displayName=i(e),o};e.s(["default",()=>o],75254)},43531,e=>{"use strict";let t=(0,e.i(75254).default)("check",[["path",{d:"M20 6 9 17l-5-5",key:"1gmf2c"}]]);e.s(["Check",()=>t],43531)},38755,e=>{"use strict";var t=e.i(43476),a=e.i(932),i=e.i(22016);let r=[{id:"cc-solbmc",name:"CC-SolBMC",title:"Condition Coverage - Solidity Bounded Model Checker",description:"A comprehensive tool for analyzing Solidity smart contracts using bounded model checking to achieve condition coverage.",detailedDescription:"We have developed a prototype named Condition Coverage for Condition Coverage Analysis for Smart Contracts using Solidity Bounded Model Checker (CC-SolBMC). We demonstrate an approach for generating test cases to satisfy the condition coverage of smart contracts using a solidity-bounded model checker.",image:"https://nitminer.com/tool%20features/CC-SolBMC.png",features:["Bounded model checking for Solidity","Condition coverage analysis","Dead code detection","Coverage metrics reporting","Automated test case generation"],languages:["Solidity"],methods:["Bounded Model Checking"],useCases:["Verify smart contract correctness","Achieve high code coverage","Detect unreachable code","Ensure condition coverage"]},{id:"cyclo-sol",name:"Cyclo-Sol",title:"Cyclometric Complexity Analysis for Solidity",description:"Analyzes the cyclometric complexity of Solidity smart contracts to identify code quality issues and refactoring opportunities.",detailedDescription:"We have developed another product, the Cyclomatic Complexity Analyser of Solidity Smart Contract (Cyclo-Sol). As a first step, we propose using Control Flow Graph to measure the Cyclomatic Complexity of smart contracts.",image:"https://nitminer.com/tool%20features/Cyclo-Sol.png",features:["Cyclomatic complexity measurement","Code complexity scoring","Function-level analysis","Refactoring recommendations","Complexity trend tracking"],languages:["Solidity"],methods:["Static Analysis"],useCases:["Identify complex functions","Improve code maintainability","Guide refactoring efforts","Establish quality metrics"]},{id:"smart-muverf",name:"Smart-MuVerf",title:"Smart Contract Mutation Verification",description:"Performs mutation testing on smart contracts to ensure comprehensive test coverage and detect subtle bugs.",detailedDescription:"We have developed another product named Mutant Verification for Smart Contract (Smart-MuVerf). The main objective of this work is to verify the created mutants for the smart contract.",image:"https://nitminer.com/tool%20features/Smart-MuVerf.png",features:["Mutation operator application","Mutation score calculation","Test effectiveness measurement","Mutant database management","Coverage analysis"],languages:["Solidity","Ethereum"],methods:["Mutation Testing"],useCases:["Validate test suite effectiveness","Improve test coverage","Detect weak test cases","Ensure code quality"]},{id:"sol-slicer",name:"Sol-Slicer",title:"Solidity Program Slicer",description:"Slices Solidity smart contracts to isolate relevant code for analysis, debugging, and understanding.",detailedDescription:"We propose a program-slicing approach for fast and efficient conditional coverage analysis of Solidity Smart Contracts and tested with test cases generated by Model Checker Engines. We generate a Smart Contract Interconnection Map for the smart contract and slice the graph by considering each conditional statement as a seed.",image:"https://nitminer.com/tool%20features/Sol-Slicer.png",features:["Static program slicing","Data flow analysis","Control flow analysis","Dependence analysis","Slice visualization"],languages:["Solidity"],methods:["Program Slicing"],useCases:["Understand code dependencies","Debug smart contracts","Analyze impact of changes","Identify relevant code segments"]},{id:"cc-solsym",name:"CC-SolSym",title:"Condition Coverage - Solidity Symbolic Execution",description:"Achieves condition coverage in Solidity smart contracts using dynamic symbolic execution techniques.",detailedDescription:"We propose a new technique to measure condition coverage criterion for smart contracts using a state based symbolic execution tool.",image:"https://nitminer.com/tool%20features/CC-SolSym.png",features:["Dynamic symbolic execution","Path exploration","Constraint solving","Test case generation","Coverage reporting"],languages:["Solidity"],methods:["Dynamic Symbolic Execution"],useCases:["Generate test cases automatically","Achieve high code coverage","Find edge cases","Validate contract behavior"]},{id:"sol-repairer",name:"Sol-Repairer",title:"Solidity Smart Contract Dead Code Repairer",description:"Automatically identifies and repairs dead code in Solidity smart contracts, improving code efficiency.",detailedDescription:"Sol-Repairer is a tool that provides the implementation for identifying dead code segments from solidity-written smart contracts and then repairing them. Extensive experiments show that Sol-Repairer optimizes dead code better than the solidity compiler. The study also demonstrates that optimizing dead code reduces gas consumption significantly for smart contracts.",image:"https://nitminer.com/tool%20features/Sol-Repairer.png",features:["Dead code detection","Automatic code repair","Condition simplification","Code optimization","Refactoring suggestions"],languages:["Solidity"],methods:["Code Analysis"],useCases:["Remove unreachable code","Optimize smart contracts","Reduce bytecode size","Improve gas efficiency"]},{id:"verisol-mce",name:"VeriSol-MCE",title:"VeriSol Model Checker Engine",description:"A comprehensive verification tool for Solidity smart contracts using model checking engines to ensure correctness.",detailedDescription:"We present a new tool to measure condition coverage criterion for smart contracts using Solidity-based model checkers. We employing both the Bounded Model Checker (BMC) and Constrained Horn Clauses (CHC).",image:"https://nitminer.com/tool%20features/VeriSol-MCE.png",features:["Model checking verification","Condition coverage analysis","Invariant checking","Property verification","Counterexample generation"],languages:["Solidity"],methods:["Model Checking"],useCases:["Verify contract properties","Check invariants","Find security vulnerabilities","Ensure contract correctness"]}];var s=e.i(92199);function o(e){let o,n,c,d=(0,a.c)(5),{activeToolId:l}=e,m=void 0===l?null:l;return d[0]===Symbol.for("react.memo_cache_sentinel")?(o=(0,t.jsx)("h2",{className:"text-xl font-bold text-black dark:text-white mb-6",children:"Our Tools"}),d[0]=o):o=d[0],d[1]!==m?(n=r.map(e=>(0,t.jsxs)(i.default,{href:`/tools/${e.id}`,className:`flex items-center justify-between p-3 rounded-lg transition-colors ${m===e.id?"bg-blue-600 text-white dark:bg-blue-700":"text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800"}`,children:[(0,t.jsx)("span",{className:"font-medium text-sm",children:e.name}),(0,t.jsx)(s.FiChevronRight,{size:16,className:"opacity-75"})]},e.id)),d[1]=m,d[2]=n):n=d[2],d[3]!==n?(c=(0,t.jsx)("aside",{className:"w-full md:w-64 bg-white dark:bg-gray-900 border-b md:border-b-0 md:border-r border-gray-200 dark:border-gray-800 fixed sticky bottom-0",children:(0,t.jsxs)("div",{className:"p-4 md:p-6 fixed",children:[o,(0,t.jsx)("nav",{className:"space-y-2",children:n})]})}),d[3]=n,d[4]=c):c=d[4],c}e.s(["ToolsSidebar",()=>o],38755)},24940,e=>{"use strict";var t=e.i(43476),a=e.i(92199);function i({tool:e}){return e?(0,t.jsx)("section",{className:"w-full py-8 md:py-16 bg-white dark:bg-black",children:(0,t.jsxs)("div",{className:"max-w-4xl mx-auto px-4 sm:px-6 lg:px-8",children:[(0,t.jsxs)("div",{className:"mb-8 animate-fadeIn",children:[(0,t.jsx)("h1",{className:"text-4xl md:text-5xl font-bold text-black dark:text-white mb-4",children:e.title}),(0,t.jsx)("p",{className:"text-lg text-gray-600 dark:text-gray-300 leading-relaxed",children:e.description})]}),e.image&&(0,t.jsx)("div",{className:"mb-12 animate-fadeIn",children:(0,t.jsx)("img",{src:e.image,alt:e.name,className:"w-full h-96 object-contain rounded-lg border border-gray-200 dark:border-gray-800 shadow-lg"})}),e.detailedDescription&&(0,t.jsxs)("div",{className:"mb-12 animate-fadeIn p-6 bg-blue-50 dark:bg-gray-900 border border-blue-200 dark:border-gray-800 rounded-lg",children:[(0,t.jsxs)("h2",{className:"text-2xl font-bold text-black dark:text-white mb-4",children:["About ",e.name]}),(0,t.jsx)("p",{className:"text-gray-700 dark:text-gray-300 leading-relaxed",children:e.detailedDescription})]}),(0,t.jsxs)("div",{className:"grid md:grid-cols-2 gap-6 mb-12",children:[(0,t.jsxs)("div",{className:"animate-fadeIn p-6 border border-gray-200 dark:border-gray-800 rounded-lg",children:[(0,t.jsxs)("h3",{className:"flex items-center gap-2 text-lg font-bold text-black dark:text-white mb-4",children:[(0,t.jsx)(a.FiCode,{size:20}),"Supported Languages"]}),(0,t.jsx)("div",{className:"space-y-2",children:e.languages.map((e,a)=>(0,t.jsxs)("div",{className:"flex items-center gap-2 text-gray-700 dark:text-gray-300",children:[(0,t.jsx)("span",{className:"w-2 h-2 bg-green-500 rounded-full"}),e]},a))})]}),(0,t.jsxs)("div",{className:"animate-fadeIn p-6 border border-gray-200 dark:border-gray-800 rounded-lg",children:[(0,t.jsxs)("h3",{className:"flex items-center gap-2 text-lg font-bold text-black dark:text-white mb-4",children:[(0,t.jsx)(a.FiTarget,{size:20}),"Analysis Methods"]}),(0,t.jsx)("div",{className:"space-y-2",children:e.methods.map((e,a)=>(0,t.jsxs)("div",{className:"flex items-center gap-2 text-gray-700 dark:text-gray-300",children:[(0,t.jsx)("span",{className:"w-2 h-2 bg-purple-500 rounded-full"}),e]},a))})]})]}),(0,t.jsxs)("div",{className:"mb-12 animate-fadeIn",children:[(0,t.jsx)("h2",{className:"text-2xl font-bold text-black dark:text-white mb-6",children:"Key Features"}),(0,t.jsx)("div",{className:"grid md:grid-cols-2 gap-4",children:e.features.map((e,i)=>(0,t.jsxs)("div",{className:"flex items-start gap-3 p-4 bg-gray-50 dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-800 hover:border-blue-400 dark:hover:border-blue-600 transition-colors",children:[(0,t.jsx)(a.FiCheck,{className:"text-green-500 flex-shrink-0 mt-1",size:20}),(0,t.jsx)("span",{className:"text-gray-700 dark:text-gray-300",children:e})]},i))})]}),(0,t.jsxs)("div",{className:"mb-12 animate-fadeIn",children:[(0,t.jsx)("h2",{className:"text-2xl font-bold text-black dark:text-white mb-6",children:"Use Cases"}),(0,t.jsx)("div",{className:"space-y-4",children:e.useCases.map((e,a)=>(0,t.jsx)("div",{className:"p-4 bg-blue-50 dark:bg-gray-900 border-l-4 border-blue-600 dark:border-blue-400 rounded",children:(0,t.jsx)("p",{className:"text-gray-700 dark:text-gray-300",children:e})},a))})]}),(0,t.jsxs)("div",{className:"animate-fadeIn bg-blue-600 dark:bg-blue-900 rounded-lg p-8 text-center text-white",children:[(0,t.jsxs)("h3",{className:"text-2xl font-bold mb-4",children:["Ready to Use ",e.name,"?"]}),(0,t.jsx)("p",{className:"mb-6 text-blue-100",children:"Get in touch with our team to request a license or demo"}),(0,t.jsx)("a",{href:"mailto:sanghu@nitw.ac.in",className:"inline-block px-8 py-3 bg-white text-blue-600 font-semibold rounded-lg hover:bg-blue-50 transition-colors",children:"Request Access"})]})]})}):(0,t.jsx)("div",{className:"flex items-center justify-center h-screen",children:(0,t.jsx)("p",{className:"text-gray-500 dark:text-gray-400",children:"Tool not found"})})}e.s(["ToolDetailComponent",()=>i])}]);
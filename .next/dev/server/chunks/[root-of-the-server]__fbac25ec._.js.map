{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/rajeshbyreddy/nitminer/client/src/lib/dbConnect.ts"],"sourcesContent":["import mongoose from 'mongoose';\n\nconst MONGODB_URI = process.env.MONGODB_URI;\n\nif (!MONGODB_URI) {\n  throw new Error('Please define the MONGODB_URI environment variable');\n}\n\ninterface Cached {\n  conn: typeof mongoose | null;\n  promise: Promise<typeof mongoose> | null;\n}\n\nlet cached: Cached = (global as any).mongoose || { conn: null, promise: null };\n\nif (!cached) {\n  cached = (global as any).mongoose = { conn: null, promise: null };\n}\n\nasync function dbConnect() {\n  if (cached.conn) {\n    return cached.conn;\n  }\n\n  if (!cached.promise) {\n    const opts = {\n      bufferCommands: false,\n    };\n\n    cached.promise = mongoose.connect(MONGODB_URI!, opts).then((mongoose) => {\n      return mongoose;\n    });\n  }\n\n  try {\n    cached.conn = await cached.promise;\n  } catch (e) {\n    cached.promise = null;\n    throw e;\n  }\n\n  return cached.conn;\n}\n\nexport default dbConnect;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW;AAE3C,IAAI,CAAC,aAAa;IAChB,MAAM,IAAI,MAAM;AAClB;AAOA,IAAI,SAAiB,yDAAgB,QAAQ,IAAI;IAAE,MAAM;IAAM,SAAS;AAAK;AAE7E,IAAI,CAAC,QAAQ;IACX,SAAS,yDAAgB,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AAClE;AAEA,eAAe;IACb,IAAI,OAAO,IAAI,EAAE;QACf,OAAO,OAAO,IAAI;IACpB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,OAAO;YACX,gBAAgB;QAClB;QAEA,OAAO,OAAO,GAAG,mKAAQ,CAAC,OAAO,CAAC,aAAc,MAAM,IAAI,CAAC,CAAC;YAC1D,OAAO;QACT;IACF;IAEA,IAAI;QACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IACpC,EAAE,OAAO,GAAG;QACV,OAAO,OAAO,GAAG;QACjB,MAAM;IACR;IAEA,OAAO,OAAO,IAAI;AACpB;uCAEe"}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///Users/rajeshbyreddy/nitminer/client/src/models/SessionManagement.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\n\nexport interface ISessionManagement extends Document {\n  userId: mongoose.Types.ObjectId;\n  email: string;\n  deviceId: string;\n  deviceFingerprint: string;\n  deviceName: string;\n  browser: string;\n  os: string;\n  ipAddress: string;\n  sessionToken: string;\n  isActive: boolean;\n  loginTime: Date;\n  lastActivity: Date;\n  expiresAt: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nconst sessionManagementSchema = new Schema<ISessionManagement>(\n  {\n    userId: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User',\n      required: true,\n      index: true,\n    },\n    email: {\n      type: String,\n      required: true,\n      lowercase: true,\n      index: true,\n    },\n    deviceId: {\n      type: String,\n      required: true,\n      index: true,\n    },\n    deviceFingerprint: {\n      type: String,\n      required: true,\n      index: true,\n    },\n    deviceName: {\n      type: String,\n      default: 'Unknown Device',\n    },\n    browser: {\n      type: String,\n      default: 'Unknown',\n    },\n    os: {\n      type: String,\n      default: 'Unknown',\n    },\n    ipAddress: {\n      type: String,\n      default: null,\n    },\n    sessionToken: {\n      type: String,\n      required: true,\n      unique: true,\n      index: true,\n    },\n    isActive: {\n      type: Boolean,\n      default: true,\n      index: true,\n    },\n    loginTime: {\n      type: Date,\n      required: true,\n      default: () => new Date(),\n    },\n    lastActivity: {\n      type: Date,\n      required: true,\n      default: () => new Date(),\n    },\n    expiresAt: {\n      type: Date,\n      required: true,\n      default: () => new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\n      // TTL index configured below\n    },\n  },\n  {\n    timestamps: true,\n  }\n);\n\n// Index for finding active sessions for a user\nsessionManagementSchema.index({ userId: 1, isActive: 1 });\nsessionManagementSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 }); // TTL index\n\nexport const SessionManagement =\n  mongoose.models.SessionManagement ||\n  mongoose.model<ISessionManagement>('SessionManagement', sessionManagementSchema);\n"],"names":[],"mappings":";;;;AAAA;;AAoBA,MAAM,0BAA0B,IAAI,kKAAM,CACxC;IACE,QAAQ;QACN,MAAM,mKAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ;QACpC,KAAK;QACL,UAAU;QACV,OAAO;IACT;IACA,OAAO;QACL,MAAM;QACN,UAAU;QACV,WAAW;QACX,OAAO;IACT;IACA,UAAU;QACR,MAAM;QACN,UAAU;QACV,OAAO;IACT;IACA,mBAAmB;QACjB,MAAM;QACN,UAAU;QACV,OAAO;IACT;IACA,YAAY;QACV,MAAM;QACN,SAAS;IACX;IACA,SAAS;QACP,MAAM;QACN,SAAS;IACX;IACA,IAAI;QACF,MAAM;QACN,SAAS;IACX;IACA,WAAW;QACT,MAAM;QACN,SAAS;IACX;IACA,cAAc;QACZ,MAAM;QACN,UAAU;QACV,QAAQ;QACR,OAAO;IACT;IACA,UAAU;QACR,MAAM;QACN,SAAS;QACT,OAAO;IACT;IACA,WAAW;QACT,MAAM;QACN,UAAU;QACV,SAAS,IAAM,IAAI;IACrB;IACA,cAAc;QACZ,MAAM;QACN,UAAU;QACV,SAAS,IAAM,IAAI;IACrB;IACA,WAAW;QACT,MAAM;QACN,UAAU;QACV,SAAS,IAAM,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK;IAE3D;AACF,GACA;IACE,YAAY;AACd;AAGF,+CAA+C;AAC/C,wBAAwB,KAAK,CAAC;IAAE,QAAQ;IAAG,UAAU;AAAE;AACvD,wBAAwB,KAAK,CAAC;IAAE,WAAW;AAAE,GAAG;IAAE,oBAAoB;AAAE,IAAI,YAAY;AAEjF,MAAM,oBACX,mKAAQ,CAAC,MAAM,CAAC,iBAAiB,IACjC,mKAAQ,CAAC,KAAK,CAAqB,qBAAqB"}},
    {"offset": {"line": 180, "column": 0}, "map": {"version":3,"sources":["file:///Users/rajeshbyreddy/nitminer/client/src/app/api/auth/session/check-duplicate/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport dbConnect from '@/lib/dbConnect';\nimport { SessionManagement } from '@/models/SessionManagement';\n\n/**\n * POST /api/auth/session/check-duplicate\n * Check if another device/browser is already logged in with this email\n * Strictly prevents multi-browser and multi-device login\n */\nexport async function POST(request: NextRequest) {\n  try {\n    await dbConnect();\n\n    const body = await request.json();\n    const { email, deviceId, deviceFingerprint, browser } = body;\n\n    if (!email || !deviceId || !deviceFingerprint) {\n      console.warn('check-duplicate: Missing required fields', { email, deviceId, browser });\n      return NextResponse.json(\n        { error: 'Missing required fields' },\n        { status: 400 }\n      );\n    }\n\n    const normalizedEmail = email.toLowerCase();\n    console.log(`Checking duplicate sessions for ${normalizedEmail}, browser: ${browser}`);\n\n    // Find ALL active sessions for this email (strict check)\n    const activeSessions = await SessionManagement.find({\n      email: normalizedEmail,\n      isActive: true,\n    });\n\n    console.log(`Found ${activeSessions.length} active sessions for ${normalizedEmail}`);\n\n    // Check for ANY other session (different device or different browser)\n    const otherSessions = activeSessions.filter((session) => {\n      const isDifferentDevice = session.deviceId !== deviceId;\n      const isDifferentBrowser = session.browser !== browser;\n      \n      console.log(`Session check - Device: ${session.deviceId} vs ${deviceId} (different: ${isDifferentDevice}), Browser: ${session.browser} vs ${browser} (different: ${isDifferentBrowser})`);\n      \n      // Prevent login if different device\n      if (isDifferentDevice) {\n        return true;\n      }\n      // Prevent login if same device but different browser\n      if (isDifferentBrowser) {\n        return true;\n      }\n      return false;\n    });\n\n    console.log(`Found ${otherSessions.length} conflicting sessions`);\n\n    if (otherSessions.length > 0) {\n      return NextResponse.json(\n        {\n          isDuplicate: true,\n          existingSessions: otherSessions.map((session) => ({\n            id: session._id,\n            deviceName: session.deviceName,\n            browser: session.browser,\n            os: session.os,\n            loginTime: session.loginTime,\n            lastActivity: session.lastActivity,\n            ipAddress: session.ipAddress,\n          })),\n        },\n        { status: 200 }\n      );\n    }\n\n    return NextResponse.json(\n      { isDuplicate: false, existingSessions: [] },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('Duplicate session check error:', error);\n    return NextResponse.json(\n      { error: 'Failed to check duplicate sessions' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAOO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,IAAA,oIAAS;QAEf,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,iBAAiB,EAAE,OAAO,EAAE,GAAG;QAExD,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,mBAAmB;YAC7C,QAAQ,IAAI,CAAC,4CAA4C;gBAAE;gBAAO;gBAAU;YAAQ;YACpF,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0B,GACnC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,kBAAkB,MAAM,WAAW;QACzC,QAAQ,GAAG,CAAC,CAAC,gCAAgC,EAAE,gBAAgB,WAAW,EAAE,SAAS;QAErF,yDAAyD;QACzD,MAAM,iBAAiB,MAAM,yJAAiB,CAAC,IAAI,CAAC;YAClD,OAAO;YACP,UAAU;QACZ;QAEA,QAAQ,GAAG,CAAC,CAAC,MAAM,EAAE,eAAe,MAAM,CAAC,qBAAqB,EAAE,iBAAiB;QAEnF,sEAAsE;QACtE,MAAM,gBAAgB,eAAe,MAAM,CAAC,CAAC;YAC3C,MAAM,oBAAoB,QAAQ,QAAQ,KAAK;YAC/C,MAAM,qBAAqB,QAAQ,OAAO,KAAK;YAE/C,QAAQ,GAAG,CAAC,CAAC,wBAAwB,EAAE,QAAQ,QAAQ,CAAC,IAAI,EAAE,SAAS,aAAa,EAAE,kBAAkB,YAAY,EAAE,QAAQ,OAAO,CAAC,IAAI,EAAE,QAAQ,aAAa,EAAE,mBAAmB,CAAC,CAAC;YAExL,oCAAoC;YACpC,IAAI,mBAAmB;gBACrB,OAAO;YACT;YACA,qDAAqD;YACrD,IAAI,oBAAoB;gBACtB,OAAO;YACT;YACA,OAAO;QACT;QAEA,QAAQ,GAAG,CAAC,CAAC,MAAM,EAAE,cAAc,MAAM,CAAC,qBAAqB,CAAC;QAEhE,IAAI,cAAc,MAAM,GAAG,GAAG;YAC5B,OAAO,gJAAY,CAAC,IAAI,CACtB;gBACE,aAAa;gBACb,kBAAkB,cAAc,GAAG,CAAC,CAAC,UAAY,CAAC;wBAChD,IAAI,QAAQ,GAAG;wBACf,YAAY,QAAQ,UAAU;wBAC9B,SAAS,QAAQ,OAAO;wBACxB,IAAI,QAAQ,EAAE;wBACd,WAAW,QAAQ,SAAS;wBAC5B,cAAc,QAAQ,YAAY;wBAClC,WAAW,QAAQ,SAAS;oBAC9B,CAAC;YACH,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,aAAa;YAAO,kBAAkB,EAAE;QAAC,GAC3C;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAqC,GAC9C;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}
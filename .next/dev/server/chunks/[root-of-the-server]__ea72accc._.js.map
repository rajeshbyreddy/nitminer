{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/rajeshbyreddy/nitminer/client/src/lib/dbConnect.ts"],"sourcesContent":["import mongoose from 'mongoose';\n\nconst MONGODB_URI = process.env.MONGODB_URI;\n\nif (!MONGODB_URI) {\n  throw new Error('Please define the MONGODB_URI environment variable');\n}\n\ninterface Cached {\n  conn: typeof mongoose | null;\n  promise: Promise<typeof mongoose> | null;\n}\n\nlet cached: Cached = (global as any).mongoose || { conn: null, promise: null };\n\nif (!cached) {\n  cached = (global as any).mongoose = { conn: null, promise: null };\n}\n\nasync function dbConnect() {\n  if (cached.conn) {\n    return cached.conn;\n  }\n\n  if (!cached.promise) {\n    const opts = {\n      bufferCommands: false,\n    };\n\n    cached.promise = mongoose.connect(MONGODB_URI!, opts).then((mongoose) => {\n      return mongoose;\n    });\n  }\n\n  try {\n    cached.conn = await cached.promise;\n  } catch (e) {\n    cached.promise = null;\n    throw e;\n  }\n\n  return cached.conn;\n}\n\nexport default dbConnect;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW;AAE3C,IAAI,CAAC,aAAa;IAChB,MAAM,IAAI,MAAM;AAClB;AAOA,IAAI,SAAiB,yDAAgB,QAAQ,IAAI;IAAE,MAAM;IAAM,SAAS;AAAK;AAE7E,IAAI,CAAC,QAAQ;IACX,SAAS,yDAAgB,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AAClE;AAEA,eAAe;IACb,IAAI,OAAO,IAAI,EAAE;QACf,OAAO,OAAO,IAAI;IACpB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,OAAO;YACX,gBAAgB;QAClB;QAEA,OAAO,OAAO,GAAG,mKAAQ,CAAC,OAAO,CAAC,aAAc,MAAM,IAAI,CAAC,CAAC;YAC1D,OAAO;QACT;IACF;IAEA,IAAI;QACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IACpC,EAAE,OAAO,GAAG;QACV,OAAO,OAAO,GAAG;QACjB,MAAM;IACR;IAEA,OAAO,OAAO,IAAI;AACpB;uCAEe"}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///Users/rajeshbyreddy/nitminer/client/src/models/OTP.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\n\nexport interface IOTP extends Document {\n  email: string;\n  otp: string;\n  expiresAt: Date;\n  createdAt: Date;\n}\n\nconst otpSchema = new Schema<IOTP>(\n  {\n    email: {\n      type: String,\n      required: true,\n      lowercase: true,\n      trim: true,\n    },\n    otp: {\n      type: String,\n      required: true,\n    },\n    expiresAt: {\n      type: Date,\n      required: true,\n      default: () => new Date(Date.now() + 10 * 60 * 1000), // 10 minutes\n    },\n  },\n  {\n    timestamps: true,\n  }\n);\n\n// Index to auto-delete expired OTPs\notpSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });\n\nconst OTP = mongoose.models.OTP || mongoose.model<IOTP>('OTP', otpSchema);\n\nexport default OTP;"],"names":[],"mappings":";;;;AAAA;;AASA,MAAM,YAAY,IAAI,kKAAM,CAC1B;IACE,OAAO;QACL,MAAM;QACN,UAAU;QACV,WAAW;QACX,MAAM;IACR;IACA,KAAK;QACH,MAAM;QACN,UAAU;IACZ;IACA,WAAW;QACT,MAAM;QACN,UAAU;QACV,SAAS,IAAM,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK;IACjD;AACF,GACA;IACE,YAAY;AACd;AAGF,oCAAoC;AACpC,UAAU,KAAK,CAAC;IAAE,WAAW;AAAE,GAAG;IAAE,oBAAoB;AAAE;AAE1D,MAAM,MAAM,mKAAQ,CAAC,MAAM,CAAC,GAAG,IAAI,mKAAQ,CAAC,KAAK,CAAO,OAAO;uCAEhD"}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file:///Users/rajeshbyreddy/nitminer/client/src/models/User.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\n\nexport interface IUser extends Document {\n  name: string;\n  email: string;\n  password?: string;\n  googleId?: string;\n  role: 'user' | 'admin';\n  trialCount: number;\n  isPremium: boolean;\n  subscriptionExpiry: Date | null;\n  subscription?: {\n    plan: '1_month' | '6_months' | '12_months';\n    status: 'active' | 'expired' | 'cancelled';\n    startDate: Date;\n    endDate: Date;\n    paymentId: mongoose.Types.ObjectId;\n  };\n  settings?: {\n    emailNotifications: boolean;\n    pushNotifications: boolean;\n    marketingEmails: boolean;\n    theme: string;\n    language: string;\n    timezone: string;\n    twoFactorAuth: boolean;\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nconst userSchema = new Schema<IUser>(\n  {\n    name: {\n      type: String,\n      required: true,\n      trim: true,\n    },\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n      trim: true,\n    },\n    password: {\n      type: String,\n      select: false, // Don't return password by default\n    },\n    googleId: {\n      type: String,\n      unique: true,\n      sparse: true, // Allow null values for non-Google users\n    },\n    role: {\n      type: String,\n      enum: ['user', 'admin'],\n      default: 'user',\n    },\n    trialCount: {\n      type: Number,\n      default: 5,\n      min: 0,\n    },\n    isPremium: {\n      type: Boolean,\n      default: false,\n    },\n    subscriptionExpiry: {\n      type: Date,\n      default: null,\n    },\n    subscription: {\n      plan: {\n        type: String,\n        enum: ['1_month', '6_months', '12_months'],\n      },\n      status: {\n        type: String,\n        enum: ['active', 'expired', 'cancelled'],\n        default: 'active',\n      },\n      startDate: {\n        type: Date,\n      },\n      endDate: {\n        type: Date,\n      },\n      paymentId: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'Payment',\n      },\n    },\n    settings: {\n      emailNotifications: {\n        type: Boolean,\n        default: true,\n      },\n      pushNotifications: {\n        type: Boolean,\n        default: false,\n      },\n      marketingEmails: {\n        type: Boolean,\n        default: false,\n      },\n      theme: {\n        type: String,\n        enum: ['dark', 'light', 'auto'],\n        default: 'dark',\n      },\n      language: {\n        type: String,\n        default: 'en',\n      },\n      timezone: {\n        type: String,\n        default: 'UTC',\n      },\n      twoFactorAuth: {\n        type: Boolean,\n        default: false,\n      },\n    },\n  },\n  {\n    timestamps: true,\n  }\n);\n\n// Index for faster queries\nuserSchema.index({ isPremium: 1 });\n\nexport const User = mongoose.models.User || mongoose.model<IUser>('User', userSchema);\n"],"names":[],"mappings":";;;;AAAA;;AA+BA,MAAM,aAAa,IAAI,kKAAM,CAC3B;IACE,MAAM;QACJ,MAAM;QACN,UAAU;QACV,MAAM;IACR;IACA,OAAO;QACL,MAAM;QACN,UAAU;QACV,QAAQ;QACR,WAAW;QACX,MAAM;IACR;IACA,UAAU;QACR,MAAM;QACN,QAAQ;IACV;IACA,UAAU;QACR,MAAM;QACN,QAAQ;QACR,QAAQ;IACV;IACA,MAAM;QACJ,MAAM;QACN,MAAM;YAAC;YAAQ;SAAQ;QACvB,SAAS;IACX;IACA,YAAY;QACV,MAAM;QACN,SAAS;QACT,KAAK;IACP;IACA,WAAW;QACT,MAAM;QACN,SAAS;IACX;IACA,oBAAoB;QAClB,MAAM;QACN,SAAS;IACX;IACA,cAAc;QACZ,MAAM;YACJ,MAAM;YACN,MAAM;gBAAC;gBAAW;gBAAY;aAAY;QAC5C;QACA,QAAQ;YACN,MAAM;YACN,MAAM;gBAAC;gBAAU;gBAAW;aAAY;YACxC,SAAS;QACX;QACA,WAAW;YACT,MAAM;QACR;QACA,SAAS;YACP,MAAM;QACR;QACA,WAAW;YACT,MAAM,mKAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ;YACpC,KAAK;QACP;IACF;IACA,UAAU;QACR,oBAAoB;YAClB,MAAM;YACN,SAAS;QACX;QACA,mBAAmB;YACjB,MAAM;YACN,SAAS;QACX;QACA,iBAAiB;YACf,MAAM;YACN,SAAS;QACX;QACA,OAAO;YACL,MAAM;YACN,MAAM;gBAAC;gBAAQ;gBAAS;aAAO;YAC/B,SAAS;QACX;QACA,UAAU;YACR,MAAM;YACN,SAAS;QACX;QACA,UAAU;YACR,MAAM;YACN,SAAS;QACX;QACA,eAAe;YACb,MAAM;YACN,SAAS;QACX;IACF;AACF,GACA;IACE,YAAY;AACd;AAGF,2BAA2B;AAC3B,WAAW,KAAK,CAAC;IAAE,WAAW;AAAE;AAEzB,MAAM,OAAO,mKAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,mKAAQ,CAAC,KAAK,CAAQ,QAAQ"}},
    {"offset": {"line": 277, "column": 0}, "map": {"version":3,"sources":["file:///Users/rajeshbyreddy/nitminer/client/src/app/api/auth/verify-otp/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport dbConnect from '@/lib/dbConnect';\nimport OTP from '@/models/OTP';\nimport { User } from '@/models/User';\nimport bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\n\nexport async function POST(req: NextRequest) {\n  try {\n    const { email, otp } = await req.json();\n\n    if (!email || !otp) {\n      return NextResponse.json({ error: 'Email and OTP are required' }, { status: 400 });\n    }\n\n    await dbConnect();\n\n    // Find the OTP\n    const otpDoc = await OTP.findOne({ email, otp });\n\n    if (!otpDoc || otpDoc.expiresAt < new Date()) {\n      return NextResponse.json({ error: 'Invalid or expired OTP' }, { status: 400 });\n    }\n\n    // Delete the OTP\n    await OTP.deleteOne({ _id: otpDoc._id });\n\n    // Check if user exists (for login)\n    const user = await User.findOne({ email });\n\n    if (user) {\n      // Login: return user and token\n      const token = jwt.sign(\n        { id: user._id, email: user.email, role: user.role },\n        process.env.JWT_SECRET || 'fallback-secret',\n        { expiresIn: '7d' }\n      );\n\n      return NextResponse.json({\n        user: {\n          id: user._id,\n          name: user.name,\n          email: user.email,\n          role: user.role,\n        },\n        token,\n      });\n    } else {\n      // Signup: just return success\n      return NextResponse.json({ success: true });\n    }\n  } catch (error) {\n    console.error('Verify OTP error:', error);\n    return NextResponse.json({ error: 'Failed to verify OTP' }, { status: 500 });\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AAEA;;;;;;AAEO,eAAe,KAAK,GAAgB;IACzC,IAAI;QACF,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,MAAM,IAAI,IAAI;QAErC,IAAI,CAAC,SAAS,CAAC,KAAK;YAClB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA6B,GAAG;gBAAE,QAAQ;YAAI;QAClF;QAEA,MAAM,IAAA,oIAAS;QAEf,eAAe;QACf,MAAM,SAAS,MAAM,iIAAG,CAAC,OAAO,CAAC;YAAE;YAAO;QAAI;QAE9C,IAAI,CAAC,UAAU,OAAO,SAAS,GAAG,IAAI,QAAQ;YAC5C,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAyB,GAAG;gBAAE,QAAQ;YAAI;QAC9E;QAEA,iBAAiB;QACjB,MAAM,iIAAG,CAAC,SAAS,CAAC;YAAE,KAAK,OAAO,GAAG;QAAC;QAEtC,mCAAmC;QACnC,MAAM,OAAO,MAAM,+HAAI,CAAC,OAAO,CAAC;YAAE;QAAM;QAExC,IAAI,MAAM;YACR,+BAA+B;YAC/B,MAAM,QAAQ,kJAAG,CAAC,IAAI,CACpB;gBAAE,IAAI,KAAK,GAAG;gBAAE,OAAO,KAAK,KAAK;gBAAE,MAAM,KAAK,IAAI;YAAC,GACnD,QAAQ,GAAG,CAAC,UAAU,IAAI,mBAC1B;gBAAE,WAAW;YAAK;YAGpB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,MAAM;oBACJ,IAAI,KAAK,GAAG;oBACZ,MAAM,KAAK,IAAI;oBACf,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;gBACjB;gBACA;YACF;QACF,OAAO;YACL,8BAA8B;YAC9B,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAK;QAC3C;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qBAAqB;QACnC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAuB,GAAG;YAAE,QAAQ;QAAI;IAC5E;AACF"}}]
}
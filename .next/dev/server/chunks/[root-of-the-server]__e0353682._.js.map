{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/rajeshbyreddy/nitminer/client/src/lib/dbConnect.ts"],"sourcesContent":["import mongoose from 'mongoose';\n\nconst MONGODB_URI = process.env.MONGODB_URI;\n\nif (!MONGODB_URI) {\n  throw new Error('Please define the MONGODB_URI environment variable');\n}\n\ninterface Cached {\n  conn: typeof mongoose | null;\n  promise: Promise<typeof mongoose> | null;\n}\n\nlet cached: Cached = (global as any).mongoose || { conn: null, promise: null };\n\nif (!cached) {\n  cached = (global as any).mongoose = { conn: null, promise: null };\n}\n\nasync function dbConnect() {\n  if (cached.conn) {\n    return cached.conn;\n  }\n\n  if (!cached.promise) {\n    const opts = {\n      bufferCommands: false,\n    };\n\n    cached.promise = mongoose.connect(MONGODB_URI!, opts).then((mongoose) => {\n      return mongoose;\n    });\n  }\n\n  try {\n    cached.conn = await cached.promise;\n  } catch (e) {\n    cached.promise = null;\n    throw e;\n  }\n\n  return cached.conn;\n}\n\nexport default dbConnect;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW;AAE3C,IAAI,CAAC,aAAa;IAChB,MAAM,IAAI,MAAM;AAClB;AAOA,IAAI,SAAiB,yDAAgB,QAAQ,IAAI;IAAE,MAAM;IAAM,SAAS;AAAK;AAE7E,IAAI,CAAC,QAAQ;IACX,SAAS,yDAAgB,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AAClE;AAEA,eAAe;IACb,IAAI,OAAO,IAAI,EAAE;QACf,OAAO,OAAO,IAAI;IACpB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,OAAO;YACX,gBAAgB;QAClB;QAEA,OAAO,OAAO,GAAG,mKAAQ,CAAC,OAAO,CAAC,aAAc,MAAM,IAAI,CAAC,CAAC;YAC1D,OAAO;QACT;IACF;IAEA,IAAI;QACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IACpC,EAAE,OAAO,GAAG;QACV,OAAO,OAAO,GAAG;QACjB,MAAM;IACR;IAEA,OAAO,OAAO,IAAI;AACpB;uCAEe"}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///Users/rajeshbyreddy/nitminer/client/src/models/SessionManagement.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\n\nexport interface ISessionManagement extends Document {\n  userId: mongoose.Types.ObjectId;\n  email: string;\n  deviceId: string;\n  deviceFingerprint: string;\n  deviceName: string;\n  browser: string;\n  os: string;\n  ipAddress: string;\n  sessionToken: string;\n  isActive: boolean;\n  loginTime: Date;\n  lastActivity: Date;\n  expiresAt: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nconst sessionManagementSchema = new Schema<ISessionManagement>(\n  {\n    userId: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'User',\n      required: true,\n      index: true,\n    },\n    email: {\n      type: String,\n      required: true,\n      lowercase: true,\n      index: true,\n    },\n    deviceId: {\n      type: String,\n      required: true,\n      index: true,\n    },\n    deviceFingerprint: {\n      type: String,\n      required: true,\n      index: true,\n    },\n    deviceName: {\n      type: String,\n      default: 'Unknown Device',\n    },\n    browser: {\n      type: String,\n      default: 'Unknown',\n    },\n    os: {\n      type: String,\n      default: 'Unknown',\n    },\n    ipAddress: {\n      type: String,\n      default: null,\n    },\n    sessionToken: {\n      type: String,\n      required: true,\n      unique: true,\n      index: true,\n    },\n    isActive: {\n      type: Boolean,\n      default: true,\n      index: true,\n    },\n    loginTime: {\n      type: Date,\n      required: true,\n      default: () => new Date(),\n    },\n    lastActivity: {\n      type: Date,\n      required: true,\n      default: () => new Date(),\n    },\n    expiresAt: {\n      type: Date,\n      required: true,\n      default: () => new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\n      // TTL index configured below\n    },\n  },\n  {\n    timestamps: true,\n  }\n);\n\n// Index for finding active sessions for a user\nsessionManagementSchema.index({ userId: 1, isActive: 1 });\nsessionManagementSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 }); // TTL index\n\nexport const SessionManagement =\n  mongoose.models.SessionManagement ||\n  mongoose.model<ISessionManagement>('SessionManagement', sessionManagementSchema);\n"],"names":[],"mappings":";;;;AAAA;;AAoBA,MAAM,0BAA0B,IAAI,kKAAM,CACxC;IACE,QAAQ;QACN,MAAM,mKAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ;QACpC,KAAK;QACL,UAAU;QACV,OAAO;IACT;IACA,OAAO;QACL,MAAM;QACN,UAAU;QACV,WAAW;QACX,OAAO;IACT;IACA,UAAU;QACR,MAAM;QACN,UAAU;QACV,OAAO;IACT;IACA,mBAAmB;QACjB,MAAM;QACN,UAAU;QACV,OAAO;IACT;IACA,YAAY;QACV,MAAM;QACN,SAAS;IACX;IACA,SAAS;QACP,MAAM;QACN,SAAS;IACX;IACA,IAAI;QACF,MAAM;QACN,SAAS;IACX;IACA,WAAW;QACT,MAAM;QACN,SAAS;IACX;IACA,cAAc;QACZ,MAAM;QACN,UAAU;QACV,QAAQ;QACR,OAAO;IACT;IACA,UAAU;QACR,MAAM;QACN,SAAS;QACT,OAAO;IACT;IACA,WAAW;QACT,MAAM;QACN,UAAU;QACV,SAAS,IAAM,IAAI;IACrB;IACA,cAAc;QACZ,MAAM;QACN,UAAU;QACV,SAAS,IAAM,IAAI;IACrB;IACA,WAAW;QACT,MAAM;QACN,UAAU;QACV,SAAS,IAAM,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK;IAE3D;AACF,GACA;IACE,YAAY;AACd;AAGF,+CAA+C;AAC/C,wBAAwB,KAAK,CAAC;IAAE,QAAQ;IAAG,UAAU;AAAE;AACvD,wBAAwB,KAAK,CAAC;IAAE,WAAW;AAAE,GAAG;IAAE,oBAAoB;AAAE,IAAI,YAAY;AAEjF,MAAM,oBACX,mKAAQ,CAAC,MAAM,CAAC,iBAAiB,IACjC,mKAAQ,CAAC,KAAK,CAAqB,qBAAqB"}},
    {"offset": {"line": 180, "column": 0}, "map": {"version":3,"sources":["file:///Users/rajeshbyreddy/nitminer/client/src/app/api/auth/session/invalidate-others/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport dbConnect from '@/lib/dbConnect';\nimport { SessionManagement } from '@/models/SessionManagement';\n\n/**\n * POST /api/auth/session/invalidate-others\n * Invalidate all other sessions for the user\n */\nexport async function POST(request: NextRequest) {\n  try {\n    await dbConnect();\n\n    const body = await request.json();\n    const { userId, deviceId } = body;\n\n    if (!userId || !deviceId) {\n      return NextResponse.json(\n        { error: 'Missing required fields' },\n        { status: 400 }\n      );\n    }\n\n    // Invalidate all sessions except the current one\n    const result = await SessionManagement.updateMany(\n      { userId, deviceId: { $ne: deviceId }, isActive: true },\n      { isActive: false }\n    );\n\n    return NextResponse.json(\n      {\n        success: true,\n        invalidatedCount: result.modifiedCount,\n      },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('Session invalidation error:', error);\n    return NextResponse.json(\n      { error: 'Failed to invalidate sessions' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAMO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,IAAA,oIAAS;QAEf,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG;QAE7B,IAAI,CAAC,UAAU,CAAC,UAAU;YACxB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0B,GACnC;gBAAE,QAAQ;YAAI;QAElB;QAEA,iDAAiD;QACjD,MAAM,SAAS,MAAM,yJAAiB,CAAC,UAAU,CAC/C;YAAE;YAAQ,UAAU;gBAAE,KAAK;YAAS;YAAG,UAAU;QAAK,GACtD;YAAE,UAAU;QAAM;QAGpB,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,kBAAkB,OAAO,aAAa;QACxC,GACA;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAgC,GACzC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}
{"version":3,"sources":["../../../../src/components/Header.js/__nextjs-internal-proxy.mjs","../../../../src/components/ToolsSidebar.jsx/__nextjs-internal-proxy.mjs","../../../../src/components/ToolDetailComponent.jsx/__nextjs-internal-proxy.mjs","../../../../src/app/tools/%5BtoolId%5D/page.js","../../../../src/data/toolsData.js"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/components/Header.js from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/Header.js\",\n    \"default\",\n);\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ToolsSidebar = registerClientReference(\n    function() { throw new Error(\"Attempted to call ToolsSidebar() from the server but ToolsSidebar is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/ToolsSidebar.jsx\",\n    \"ToolsSidebar\",\n);\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ToolDetailComponent = registerClientReference(\n    function() { throw new Error(\"Attempted to call ToolDetailComponent() from the server but ToolDetailComponent is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/ToolDetailComponent.jsx\",\n    \"ToolDetailComponent\",\n);\n","import Header from \"@/components/Header\";\nimport { ToolsSidebar } from \"@/components/ToolsSidebar\";\nimport { ToolDetailComponent } from \"@/components/ToolDetailComponent\";\nimport { Footer } from \"@/components/Footer\";\nimport { getToolById, getAllToolIds } from \"@/data/toolsData\";\n\nexport async function generateStaticParams() {\n  return getAllToolIds().map((id) => ({\n    toolId: id,\n  }))\n}\n\nexport async function generateMetadata({ params }) {\n  const { toolId } = await params\n  const tool = getToolById(toolId)\n  return {\n    title: tool ? tool.name : \"Tool Not Found\",\n    description: tool ? tool.description : \"Tool details\",\n  }\n}\n\nexport default async function ToolPage({ params }) {\n  const { toolId } = await params\n  const tool = getToolById(toolId)\n\n  return (\n    <div className=\"flex min-h-screen flex-col bg-white dark:bg-black font-sans\">\n      <Header />\n      <div className=\"flex flex-1 overflow-hidden\">\n        <div className=\"fixed left-0 top-0 h-screen pt-20 w-full md:w-64 overflow-y-auto z-40 md:relative md:pt-0 hidden md:block\">\n          <ToolsSidebar activeToolId={toolId} />\n        </div>\n        <main className=\"flex-1 overflow-y-auto md:ml-0\">\n          <ToolDetailComponent tool={tool} />\n        </main>\n      </div>\n    </div>\n  )\n}\n","export const toolsData = [\n  {\n    id: \"cc-solbmc\",\n    name: \"CC-SolBMC\",\n    title: \"Condition Coverage - Solidity Bounded Model Checker\",\n    description: \"A comprehensive tool for analyzing Solidity smart contracts using bounded model checking to achieve condition coverage.\",\n    detailedDescription: \"We have developed a prototype named Condition Coverage for Condition Coverage Analysis for Smart Contracts using Solidity Bounded Model Checker (CC-SolBMC). We demonstrate an approach for generating test cases to satisfy the condition coverage of smart contracts using a solidity-bounded model checker.\",\n    image: \"https://nitminer.com/tool%20features/CC-SolBMC.png\",\n    features: [\n      \"Bounded model checking for Solidity\",\n      \"Condition coverage analysis\",\n      \"Dead code detection\",\n      \"Coverage metrics reporting\",\n      \"Automated test case generation\"\n    ],\n    languages: [\"Solidity\"],\n    methods: [\"Bounded Model Checking\"],\n    useCases: [\n      \"Verify smart contract correctness\",\n      \"Achieve high code coverage\",\n      \"Detect unreachable code\",\n      \"Ensure condition coverage\"\n    ]\n  },\n  {\n    id: \"cyclo-sol\",\n    name: \"Cyclo-Sol\",\n    title: \"Cyclometric Complexity Analysis for Solidity\",\n    description: \"Analyzes the cyclometric complexity of Solidity smart contracts to identify code quality issues and refactoring opportunities.\",\n    detailedDescription: \"We have developed another product, the Cyclomatic Complexity Analyser of Solidity Smart Contract (Cyclo-Sol). As a first step, we propose using Control Flow Graph to measure the Cyclomatic Complexity of smart contracts.\",\n    image: \"https://nitminer.com/tool%20features/Cyclo-Sol.png\",\n    features: [\n      \"Cyclomatic complexity measurement\",\n      \"Code complexity scoring\",\n      \"Function-level analysis\",\n      \"Refactoring recommendations\",\n      \"Complexity trend tracking\"\n    ],\n    languages: [\"Solidity\"],\n    methods: [\"Static Analysis\"],\n    useCases: [\n      \"Identify complex functions\",\n      \"Improve code maintainability\",\n      \"Guide refactoring efforts\",\n      \"Establish quality metrics\"\n    ]\n  },\n  {\n    id: \"smart-muverf\",\n    name: \"Smart-MuVerf\",\n    title: \"Smart Contract Mutation Verification\",\n    description: \"Performs mutation testing on smart contracts to ensure comprehensive test coverage and detect subtle bugs.\",\n    detailedDescription: \"We have developed another product named Mutant Verification for Smart Contract (Smart-MuVerf). The main objective of this work is to verify the created mutants for the smart contract.\",\n    image: \"https://nitminer.com/tool%20features/Smart-MuVerf.png\",\n    features: [\n      \"Mutation operator application\",\n      \"Mutation score calculation\",\n      \"Test effectiveness measurement\",\n      \"Mutant database management\",\n      \"Coverage analysis\"\n    ],\n    languages: [\"Solidity\", \"Ethereum\"],\n    methods: [\"Mutation Testing\"],\n    useCases: [\n      \"Validate test suite effectiveness\",\n      \"Improve test coverage\",\n      \"Detect weak test cases\",\n      \"Ensure code quality\"\n    ]\n  },\n  {\n    id: \"sol-slicer\",\n    name: \"Sol-Slicer\",\n    title: \"Solidity Program Slicer\",\n    description: \"Slices Solidity smart contracts to isolate relevant code for analysis, debugging, and understanding.\",\n    detailedDescription: \"We propose a program-slicing approach for fast and efficient conditional coverage analysis of Solidity Smart Contracts and tested with test cases generated by Model Checker Engines. We generate a Smart Contract Interconnection Map for the smart contract and slice the graph by considering each conditional statement as a seed.\",\n    image: \"https://nitminer.com/tool%20features/Sol-Slicer.png\",\n    features: [\n      \"Static program slicing\",\n      \"Data flow analysis\",\n      \"Control flow analysis\",\n      \"Dependence analysis\",\n      \"Slice visualization\"\n    ],\n    languages: [\"Solidity\"],\n    methods: [\"Program Slicing\"],\n    useCases: [\n      \"Understand code dependencies\",\n      \"Debug smart contracts\",\n      \"Analyze impact of changes\",\n      \"Identify relevant code segments\"\n    ]\n  },\n  {\n    id: \"cc-solsym\",\n    name: \"CC-SolSym\",\n    title: \"Condition Coverage - Solidity Symbolic Execution\",\n    description: \"Achieves condition coverage in Solidity smart contracts using dynamic symbolic execution techniques.\",\n    detailedDescription: \"We propose a new technique to measure condition coverage criterion for smart contracts using a state based symbolic execution tool.\",\n    image: \"https://nitminer.com/tool%20features/CC-SolSym.png\",\n    features: [\n      \"Dynamic symbolic execution\",\n      \"Path exploration\",\n      \"Constraint solving\",\n      \"Test case generation\",\n      \"Coverage reporting\"\n    ],\n    languages: [\"Solidity\"],\n    methods: [\"Dynamic Symbolic Execution\"],\n    useCases: [\n      \"Generate test cases automatically\",\n      \"Achieve high code coverage\",\n      \"Find edge cases\",\n      \"Validate contract behavior\"\n    ]\n  },\n  {\n    id: \"sol-repairer\",\n    name: \"Sol-Repairer\",\n    title: \"Solidity Smart Contract Dead Code Repairer\",\n    description: \"Automatically identifies and repairs dead code in Solidity smart contracts, improving code efficiency.\",\n    detailedDescription: \"Sol-Repairer is a tool that provides the implementation for identifying dead code segments from solidity-written smart contracts and then repairing them. Extensive experiments show that Sol-Repairer optimizes dead code better than the solidity compiler. The study also demonstrates that optimizing dead code reduces gas consumption significantly for smart contracts.\",\n    image: \"https://nitminer.com/tool%20features/Sol-Repairer.png\",\n    features: [\n      \"Dead code detection\",\n      \"Automatic code repair\",\n      \"Condition simplification\",\n      \"Code optimization\",\n      \"Refactoring suggestions\"\n    ],\n    languages: [\"Solidity\"],\n    methods: [\"Code Analysis\"],\n    useCases: [\n      \"Remove unreachable code\",\n      \"Optimize smart contracts\",\n      \"Reduce bytecode size\",\n      \"Improve gas efficiency\"\n    ]\n  },\n  {\n    id: \"verisol-mce\",\n    name: \"VeriSol-MCE\",\n    title: \"VeriSol Model Checker Engine\",\n    description: \"A comprehensive verification tool for Solidity smart contracts using model checking engines to ensure correctness.\",\n    detailedDescription: \"We present a new tool to measure condition coverage criterion for smart contracts using Solidity-based model checkers. We employing both the Bounded Model Checker (BMC) and Constrained Horn Clauses (CHC).\",\n    image: \"https://nitminer.com/tool%20features/VeriSol-MCE.png\",\n    features: [\n      \"Model checking verification\",\n      \"Condition coverage analysis\",\n      \"Invariant checking\",\n      \"Property verification\",\n      \"Counterexample generation\"\n    ],\n    languages: [\"Solidity\"],\n    methods: [\"Model Checking\"],\n    useCases: [\n      \"Verify contract properties\",\n      \"Check invariants\",\n      \"Find security vulnerabilities\",\n      \"Ensure contract correctness\"\n    ]\n  }\n]\n\nexport function getToolById(id) {\n  return toolsData.find(tool => tool.id === id)\n}\n\nexport function getAllToolIds() {\n  return toolsData.map(tool => tool.id)\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2]}
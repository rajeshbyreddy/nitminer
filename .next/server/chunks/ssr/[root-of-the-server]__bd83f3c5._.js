module.exports=[93695,(a,b,c)=>{b.exports=a.x("next/dist/shared/lib/no-fallback-error.external.js",()=>require("next/dist/shared/lib/no-fallback-error.external.js"))},69264,a=>{a.n(a.i(54832))},81967,a=>{a.n(a.i(29735))},43619,a=>{a.n(a.i(79962))},13718,a=>{a.n(a.i(85523))},18198,a=>{a.n(a.i(45518))},52571,a=>{"use strict";a.s(["default",()=>b]);let b=(0,a.i(11857).registerClientReference)(function(){throw Error("Attempted to call the default export of [project]/src/components/Header.js <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"[project]/src/components/Header.js <module evaluation>","default")},62401,a=>{"use strict";a.s(["default",()=>b]);let b=(0,a.i(11857).registerClientReference)(function(){throw Error("Attempted to call the default export of [project]/src/components/Header.js from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"[project]/src/components/Header.js","default")},91418,a=>{"use strict";a.i(52571);var b=a.i(62401);a.n(b)},50013,a=>{"use strict";a.s(["ToolsSidebar",()=>b]);let b=(0,a.i(11857).registerClientReference)(function(){throw Error("Attempted to call ToolsSidebar() from the server but ToolsSidebar is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"[project]/src/components/ToolsSidebar.jsx <module evaluation>","ToolsSidebar")},89347,a=>{"use strict";a.s(["ToolsSidebar",()=>b]);let b=(0,a.i(11857).registerClientReference)(function(){throw Error("Attempted to call ToolsSidebar() from the server but ToolsSidebar is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"[project]/src/components/ToolsSidebar.jsx","ToolsSidebar")},18134,a=>{"use strict";a.i(50013);var b=a.i(89347);a.n(b)},97274,a=>{"use strict";a.s(["ToolDetailComponent",()=>b]);let b=(0,a.i(11857).registerClientReference)(function(){throw Error("Attempted to call ToolDetailComponent() from the server but ToolDetailComponent is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"[project]/src/components/ToolDetailComponent.jsx <module evaluation>","ToolDetailComponent")},21326,a=>{"use strict";a.s(["ToolDetailComponent",()=>b]);let b=(0,a.i(11857).registerClientReference)(function(){throw Error("Attempted to call ToolDetailComponent() from the server but ToolDetailComponent is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"[project]/src/components/ToolDetailComponent.jsx","ToolDetailComponent")},66731,a=>{"use strict";a.i(97274);var b=a.i(21326);a.n(b)},89316,a=>{"use strict";var b=a.i(7997),c=a.i(91418),d=a.i(18134),e=a.i(66731);a.i(98679);let f=[{id:"cc-solbmc",name:"CC-SolBMC",title:"Condition Coverage - Solidity Bounded Model Checker",description:"A comprehensive tool for analyzing Solidity smart contracts using bounded model checking to achieve condition coverage.",detailedDescription:"We have developed a prototype named Condition Coverage for Condition Coverage Analysis for Smart Contracts using Solidity Bounded Model Checker (CC-SolBMC). We demonstrate an approach for generating test cases to satisfy the condition coverage of smart contracts using a solidity-bounded model checker.",image:"https://nitminer.com/tool%20features/CC-SolBMC.png",features:["Bounded model checking for Solidity","Condition coverage analysis","Dead code detection","Coverage metrics reporting","Automated test case generation"],languages:["Solidity"],methods:["Bounded Model Checking"],useCases:["Verify smart contract correctness","Achieve high code coverage","Detect unreachable code","Ensure condition coverage"]},{id:"cyclo-sol",name:"Cyclo-Sol",title:"Cyclometric Complexity Analysis for Solidity",description:"Analyzes the cyclometric complexity of Solidity smart contracts to identify code quality issues and refactoring opportunities.",detailedDescription:"We have developed another product, the Cyclomatic Complexity Analyser of Solidity Smart Contract (Cyclo-Sol). As a first step, we propose using Control Flow Graph to measure the Cyclomatic Complexity of smart contracts.",image:"https://nitminer.com/tool%20features/Cyclo-Sol.png",features:["Cyclomatic complexity measurement","Code complexity scoring","Function-level analysis","Refactoring recommendations","Complexity trend tracking"],languages:["Solidity"],methods:["Static Analysis"],useCases:["Identify complex functions","Improve code maintainability","Guide refactoring efforts","Establish quality metrics"]},{id:"smart-muverf",name:"Smart-MuVerf",title:"Smart Contract Mutation Verification",description:"Performs mutation testing on smart contracts to ensure comprehensive test coverage and detect subtle bugs.",detailedDescription:"We have developed another product named Mutant Verification for Smart Contract (Smart-MuVerf). The main objective of this work is to verify the created mutants for the smart contract.",image:"https://nitminer.com/tool%20features/Smart-MuVerf.png",features:["Mutation operator application","Mutation score calculation","Test effectiveness measurement","Mutant database management","Coverage analysis"],languages:["Solidity","Ethereum"],methods:["Mutation Testing"],useCases:["Validate test suite effectiveness","Improve test coverage","Detect weak test cases","Ensure code quality"]},{id:"sol-slicer",name:"Sol-Slicer",title:"Solidity Program Slicer",description:"Slices Solidity smart contracts to isolate relevant code for analysis, debugging, and understanding.",detailedDescription:"We propose a program-slicing approach for fast and efficient conditional coverage analysis of Solidity Smart Contracts and tested with test cases generated by Model Checker Engines. We generate a Smart Contract Interconnection Map for the smart contract and slice the graph by considering each conditional statement as a seed.",image:"https://nitminer.com/tool%20features/Sol-Slicer.png",features:["Static program slicing","Data flow analysis","Control flow analysis","Dependence analysis","Slice visualization"],languages:["Solidity"],methods:["Program Slicing"],useCases:["Understand code dependencies","Debug smart contracts","Analyze impact of changes","Identify relevant code segments"]},{id:"cc-solsym",name:"CC-SolSym",title:"Condition Coverage - Solidity Symbolic Execution",description:"Achieves condition coverage in Solidity smart contracts using dynamic symbolic execution techniques.",detailedDescription:"We propose a new technique to measure condition coverage criterion for smart contracts using a state based symbolic execution tool.",image:"https://nitminer.com/tool%20features/CC-SolSym.png",features:["Dynamic symbolic execution","Path exploration","Constraint solving","Test case generation","Coverage reporting"],languages:["Solidity"],methods:["Dynamic Symbolic Execution"],useCases:["Generate test cases automatically","Achieve high code coverage","Find edge cases","Validate contract behavior"]},{id:"sol-repairer",name:"Sol-Repairer",title:"Solidity Smart Contract Dead Code Repairer",description:"Automatically identifies and repairs dead code in Solidity smart contracts, improving code efficiency.",detailedDescription:"Sol-Repairer is a tool that provides the implementation for identifying dead code segments from solidity-written smart contracts and then repairing them. Extensive experiments show that Sol-Repairer optimizes dead code better than the solidity compiler. The study also demonstrates that optimizing dead code reduces gas consumption significantly for smart contracts.",image:"https://nitminer.com/tool%20features/Sol-Repairer.png",features:["Dead code detection","Automatic code repair","Condition simplification","Code optimization","Refactoring suggestions"],languages:["Solidity"],methods:["Code Analysis"],useCases:["Remove unreachable code","Optimize smart contracts","Reduce bytecode size","Improve gas efficiency"]},{id:"verisol-mce",name:"VeriSol-MCE",title:"VeriSol Model Checker Engine",description:"A comprehensive verification tool for Solidity smart contracts using model checking engines to ensure correctness.",detailedDescription:"We present a new tool to measure condition coverage criterion for smart contracts using Solidity-based model checkers. We employing both the Bounded Model Checker (BMC) and Constrained Horn Clauses (CHC).",image:"https://nitminer.com/tool%20features/VeriSol-MCE.png",features:["Model checking verification","Condition coverage analysis","Invariant checking","Property verification","Counterexample generation"],languages:["Solidity"],methods:["Model Checking"],useCases:["Verify contract properties","Check invariants","Find security vulnerabilities","Ensure contract correctness"]}];function g(a){return f.find(b=>b.id===a)}async function h(){return f.map(a=>a.id).map(a=>({toolId:a}))}async function i({params:a}){let{toolId:b}=await a,c=g(b);return{title:c?c.name:"Tool Not Found",description:c?c.description:"Tool details"}}async function j({params:a}){let{toolId:f}=await a,h=g(f);return(0,b.jsxs)("div",{className:"flex min-h-screen flex-col bg-white dark:bg-black font-sans",children:[(0,b.jsx)(c.default,{}),(0,b.jsxs)("div",{className:"flex flex-1 overflow-hidden",children:[(0,b.jsx)("div",{className:"fixed left-0 top-0 h-screen pt-20 w-full md:w-64 overflow-y-auto z-40 md:relative md:pt-0 hidden md:block",children:(0,b.jsx)(d.ToolsSidebar,{activeToolId:f})}),(0,b.jsx)("main",{className:"flex-1 overflow-y-auto md:ml-0",children:(0,b.jsx)(e.ToolDetailComponent,{tool:h})})]})]})}a.s(["default",()=>j,"generateMetadata",()=>i,"generateStaticParams",()=>h],89316)}];

//# sourceMappingURL=%5Broot-of-the-server%5D__bd83f3c5._.js.map